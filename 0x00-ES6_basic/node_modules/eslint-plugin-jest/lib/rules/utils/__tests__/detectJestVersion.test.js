"use strict";

var _child_process = require("child_process");
var fs = _interopRequireWildcard(require("fs"));
var os = _interopRequireWildcard(require("os"));
var path = _interopRequireWildcard(require("path"));
var _tsNode = require("ts-node");
var _detectJestVersion = require("../detectJestVersion");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const compileFnCode = pathToFn => {
  const fnContents = fs.readFileSync(pathToFn, 'utf-8');
  return (0, _tsNode.create)({
    transpileOnly: true,
    compilerOptions: {
      sourceMap: false
    }
  }).compile(fnContents, pathToFn);
};
const compiledFn = compileFnCode(require.resolve('../detectJestVersion.ts'));
const relativePathToFn = 'eslint-plugin-jest/lib/rules/detectJestVersion.js';
const runNodeScript = (cwd, script) => {
  return (0, _child_process.spawnSync)('node', ['-e', script.split('\n').join(' ')], {
    cwd,
    encoding: 'utf-8'
  });
};
const runDetectJestVersion = cwd => {
  return runNodeScript(cwd, `
      try {
        console.log(require('${relativePathToFn}').detectJestVersion());
      } catch (error) {
        console.error(error.message);
      }
    `);
};

/**
 * Makes a new temp directory, prefixed with `eslint-plugin-jest-`
 *
 * @return {Promise<string>}
 */
const makeTempDir = () => fs.mkdtempSync(path.join(os.tmpdir(), 'eslint-plugin-jest-'));
const setupFakeProject = structure => {
  const tempDir = makeTempDir();
  for (const [filePath, contents] of Object.entries(structure)) {
    if (contents === null) {
      fs.mkdirSync(path.join(tempDir, filePath), {
        recursive: true
      });
      continue;
    }
    const folderPath = path.dirname(filePath);

    // make the directory (recursively)
    fs.mkdirSync(path.join(tempDir, folderPath), {
      recursive: true
    });
    const finalContents = typeof contents === 'string' ? contents : JSON.stringify(contents);
    fs.writeFileSync(path.join(tempDir, filePath), finalContents);
  }
  return tempDir;
};
describe('detectJestVersion', () => {
  describe('basic tests', () => {
    const packageJsonFactory = jest.fn();
    beforeEach(() => {
      jest.resetModules();
      jest.doMock(require.resolve('jest/package.json'), packageJsonFactory);
    });
    describe('when the package.json is missing the version property', () => {
      it('throws an error', () => {
        packageJsonFactory.mockReturnValue({});
        expect(() => (0, _detectJestVersion.detectJestVersion)()).toThrow(/Unable to detect Jest version/iu);
      });
    });
    it('caches versions', () => {
      packageJsonFactory.mockReturnValue({
        version: '1.2.3'
      });
      const version = (0, _detectJestVersion.detectJestVersion)();
      jest.resetModules();
      expect(_detectJestVersion.detectJestVersion).not.toThrow();
      expect((0, _detectJestVersion.detectJestVersion)()).toBe(version);
    });
  });
  describe('when in a simple project', () => {
    it('finds the correct version', () => {
      const projectDir = setupFakeProject({
        'package.json': {
          name: 'simple-project'
        },
        [`node_modules/${relativePathToFn}`]: compiledFn,
        'node_modules/jest/package.json': {
          name: 'jest',
          version: '21.0.0'
        }
      });
      const {
        stdout,
        stderr
      } = runDetectJestVersion(projectDir);
      expect(stdout.trim()).toBe('21');
      expect(stderr.trim()).toBe('');
    });
  });
  describe('when in a hoisted mono-repo', () => {
    it('finds the correct version', () => {
      const projectDir = setupFakeProject({
        'package.json': {
          name: 'mono-repo'
        },
        [`node_modules/${relativePathToFn}`]: compiledFn,
        'node_modules/jest/package.json': {
          name: 'jest',
          version: '19.0.0'
        },
        'packages/a/package.json': {
          name: 'package-a'
        },
        'packages/b/package.json': {
          name: 'package-b'
        }
      });
      const {
        stdout,
        stderr
      } = runDetectJestVersion(projectDir);
      expect(stdout.trim()).toBe('19');
      expect(stderr.trim()).toBe('');
    });
  });
  describe('when in a subproject', () => {
    it('finds the correct versions', () => {
      const projectDir = setupFakeProject({
        'backend/package.json': {
          name: 'package-a'
        },
        [`backend/node_modules/${relativePathToFn}`]: compiledFn,
        'backend/node_modules/jest/package.json': {
          name: 'jest',
          version: '24.0.0'
        },
        'frontend/package.json': {
          name: 'package-b'
        },
        [`frontend/node_modules/${relativePathToFn}`]: compiledFn,
        'frontend/node_modules/jest/package.json': {
          name: 'jest',
          version: '15.0.0'
        }
      });
      const {
        stdout: stdoutBackend,
        stderr: stderrBackend
      } = runDetectJestVersion(path.join(projectDir, 'backend'));
      expect(stdoutBackend.trim()).toBe('24');
      expect(stderrBackend.trim()).toBe('');
      const {
        stdout: stdoutFrontend,
        stderr: stderrFrontend
      } = runDetectJestVersion(path.join(projectDir, 'frontend'));
      expect(stdoutFrontend.trim()).toBe('15');
      expect(stderrFrontend.trim()).toBe('');
    });
  });
  describe('when jest is not installed', () => {
    it('throws an error', () => {
      const projectDir = setupFakeProject({
        'package.json': {
          name: 'no-jest'
        },
        [`node_modules/${relativePathToFn}`]: compiledFn,
        'node_modules/pack/package.json': {
          name: 'pack'
        }
      });
      const {
        stdout,
        stderr
      } = runDetectJestVersion(projectDir);
      expect(stdout.trim()).toBe('');
      expect(stderr.trim()).toContain('Unable to detect Jest version');
    });
  });
  describe('when jest is changed on disk', () => {
    it('uses the cached version', () => {
      const projectDir = setupFakeProject({
        'package.json': {
          name: 'no-jest'
        },
        [`node_modules/${relativePathToFn}`]: compiledFn,
        'node_modules/jest/package.json': {
          name: 'jest',
          version: '26.0.0'
        }
      });
      const {
        stdout,
        stderr
      } = runNodeScript(projectDir, `
          const { detectJestVersion } = require('${relativePathToFn}');
          const fs = require('fs');
  
          console.log(detectJestVersion());
          fs.writeFileSync(
            'node_modules/jest/package.json',
            JSON.stringify({
              name: 'jest',
              version: '25.0.0',
            }),
          );
          console.log(detectJestVersion());
        `);
      const [firstCall, secondCall] = stdout.split('\n');
      expect(firstCall).toBe('26');
      expect(secondCall).toBe('26');
      expect(stderr.trim()).toBe('');
    });
  });
});