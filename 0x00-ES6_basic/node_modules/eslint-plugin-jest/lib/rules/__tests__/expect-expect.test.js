"use strict";

var _utils = require("@typescript-eslint/utils");
var _dedent = _interopRequireDefault(require("dedent"));
var _expectExpect = _interopRequireDefault(require("../expect-expect"));
var _testUtils = require("./test-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ruleTester = new _utils.TSESLint.RuleTester({
  parser: _testUtils.espreeParser,
  parserOptions: {
    ecmaVersion: 2015
  }
});
ruleTester.run('expect-expect', _expectExpect.default, {
  valid: ['it.todo("will test something eventually")', 'test.todo("will test something eventually")', "['x']();", 'it("should pass", () => expect(true).toBeDefined())', 'test("should pass", () => expect(true).toBeDefined())', 'it("should pass", () => somePromise().then(() => expect(true).toBeDefined()))', 'it("should pass", myTest); function myTest() { expect(true).toBeDefined() }', {
    code: (0, _dedent.default)`
        test('should pass', () => {
          expect(true).toBeDefined();
          foo(true).toBe(true);
        });
      `,
    options: [{
      assertFunctionNames: ['expect', 'foo']
    }]
  }, {
    code: 'it("should return undefined",() => expectSaga(mySaga).returns());',
    options: [{
      assertFunctionNames: ['expectSaga']
    }]
  }, {
    code: "test('verifies expect method call', () => expect$(123));",
    options: [{
      assertFunctionNames: ['expect\\$']
    }]
  }, {
    code: "test('verifies expect method call', () => new Foo().expect(123));",
    options: [{
      assertFunctionNames: ['Foo.expect']
    }]
  }, {
    code: (0, _dedent.default)`
        test('verifies deep expect method call', () => {
          tester.foo().expect(123);
        });
      `,
    options: [{
      assertFunctionNames: ['tester.foo.expect']
    }]
  }, {
    code: (0, _dedent.default)`
        test('verifies chained expect method call', () => {
          tester
            .foo()
            .bar()
            .expect(456);
        });
      `,
    options: [{
      assertFunctionNames: ['tester.foo.bar.expect']
    }]
  }, {
    code: (0, _dedent.default)`
        test("verifies the function call", () => {
          td.verify(someFunctionCall())
        })
      `,
    options: [{
      assertFunctionNames: ['td.verify']
    }]
  }, {
    code: 'it("should pass", () => expect(true).toBeDefined())',
    options: [{
      assertFunctionNames: undefined,
      additionalTestBlockFunctions: undefined
    }]
  }, {
    code: (0, _dedent.default)`
        theoretically('the number {input} is correctly translated to string', theories, theory => {
          const output = NumberToLongString(theory.input);
          expect(output).toBe(theory.expected);
        })
      `,
    options: [{
      additionalTestBlockFunctions: ['theoretically']
    }]
  }],
  invalid: [{
    code: 'it("should fail", () => {});',
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'it("should fail", myTest); function myTest() {}',
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'test("should fail", () => {});',
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'test.skip("should fail", () => {});',
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'afterEach(() => {});',
    options: [{
      additionalTestBlockFunctions: ['afterEach']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: (0, _dedent.default)`
        theoretically('the number {input} is correctly translated to string', theories, theory => {
          const output = NumberToLongString(theory.input);
        })
      `,
    options: [{
      additionalTestBlockFunctions: ['theoretically']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'it("should fail", () => { somePromise.then(() => {}); });',
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'test("should fail", () => { foo(true).toBe(true); })',
    options: [{
      assertFunctionNames: ['expect']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: 'it("should also fail",() => expectSaga(mySaga).returns());',
    options: [{
      assertFunctionNames: ['expect']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }]
});

// {
//   code: `test('wildcard chained function', () => tester.foo().expect(123));`,
//   options: [{ assertFunctionNames: ['tester.*.expect'] }],
// },

ruleTester.run('wildcards', _expectExpect.default, {
  valid: [{
    code: "test('should pass *', () => expect404ToBeLoaded());",
    options: [{
      assertFunctionNames: ['expect*']
    }]
  }, {
    code: "test('should pass *', () => expect.toHaveStatus404());",
    options: [{
      assertFunctionNames: ['expect.**']
    }]
  }, {
    code: "test('should pass', () => tester.foo().expect(123));",
    options: [{
      assertFunctionNames: ['tester.*.expect']
    }]
  }, {
    code: "test('should pass **', () => tester.foo().expect(123));",
    options: [{
      assertFunctionNames: ['**']
    }]
  }, {
    code: "test('should pass *', () => tester.foo().expect(123));",
    options: [{
      assertFunctionNames: ['*']
    }]
  }, {
    code: "test('should pass', () => tester.foo().expect(123));",
    options: [{
      assertFunctionNames: ['tester.**']
    }]
  }, {
    code: "test('should pass', () => tester.foo().expect(123));",
    options: [{
      assertFunctionNames: ['tester.*']
    }]
  }, {
    code: "test('should pass', () => tester.foo().bar().expectIt(456));",
    options: [{
      assertFunctionNames: ['tester.**.expect*']
    }]
  }, {
    code: "test('should pass', () => request.get().foo().expect(456));",
    options: [{
      assertFunctionNames: ['request.**.expect']
    }]
  }, {
    code: "test('should pass', () => request.get().foo().expect(456));",
    options: [{
      assertFunctionNames: ['request.**.e*e*t']
    }]
  }],
  invalid: [{
    code: "test('should fail', () => request.get().foo().expect(456));",
    options: [{
      assertFunctionNames: ['request.*.expect']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: "test('should fail', () => request.get().foo().bar().expect(456));",
    options: [{
      assertFunctionNames: ['request.foo**.expect']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: "test('should fail', () => tester.request(123));",
    options: [{
      assertFunctionNames: ['request.*']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: "test('should fail', () => request(123));",
    options: [{
      assertFunctionNames: ['request.*']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: "test('should fail', () => request(123));",
    options: [{
      assertFunctionNames: ['request.**']
    }],
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }]
});
ruleTester.run('expect-expect (aliases)', _expectExpect.default, {
  valid: [{
    code: (0, _dedent.default)`
        import { test } from '@jest/globals';

        test('should pass', () => {
          expect(true).toBeDefined();
          foo(true).toBe(true);
        });
      `,
    options: [{
      assertFunctionNames: ['expect', 'foo']
    }],
    parserOptions: {
      sourceType: 'module'
    }
  }, {
    code: (0, _dedent.default)`
        import { test as checkThat } from '@jest/globals';

        checkThat('this passes', () => {
          expect(true).toBeDefined();
          foo(true).toBe(true);
        });
      `,
    options: [{
      assertFunctionNames: ['expect', 'foo']
    }],
    parserOptions: {
      sourceType: 'module'
    }
  }, {
    code: (0, _dedent.default)`
        const { test } = require('@jest/globals');

        test('verifies chained expect method call', () => {
          tester
            .foo()
            .bar()
            .expect(456);
        });
      `,
    options: [{
      assertFunctionNames: ['tester.foo.bar.expect']
    }],
    parserOptions: {
      sourceType: 'module'
    }
  }],
  invalid: [{
    code: (0, _dedent.default)`
        import { test as checkThat } from '@jest/globals';

        checkThat('this passes', () => {
          // ...
        });
      `,
    options: [{
      assertFunctionNames: ['expect', 'foo']
    }],
    parserOptions: {
      sourceType: 'module'
    },
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }, {
    code: (0, _dedent.default)`
        import { test as checkThat } from '@jest/globals';

        checkThat.skip('this passes', () => {
          // ...
        });
      `,
    parserOptions: {
      sourceType: 'module'
    },
    errors: [{
      messageId: 'noAssertions',
      type: _utils.AST_NODE_TYPES.CallExpression
    }]
  }]
});