"use strict";

var _utils = require("@typescript-eslint/utils");
var _dedent = _interopRequireDefault(require("dedent"));
var _requireToThrowMessage = _interopRequireDefault(require("../require-to-throw-message"));
var _testUtils = require("./test-utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const ruleTester = new _utils.TSESLint.RuleTester({
  parser: _testUtils.espreeParser,
  parserOptions: {
    ecmaVersion: 2017
  }
});
ruleTester.run('require-to-throw-message', _requireToThrowMessage.default, {
  valid: [
  // String
  "expect(() => { throw new Error('a'); }).toThrow('a');", "expect(() => { throw new Error('a'); }).toThrowError('a');", (0, _dedent.default)`
      test('string', async () => {
        const throwErrorAsync = async () => { throw new Error('a') };
        await expect(throwErrorAsync()).rejects.toThrow('a');
        await expect(throwErrorAsync()).rejects.toThrowError('a');
      })
    `,
  // Template literal
  "const a = 'a'; expect(() => { throw new Error('a'); }).toThrow(`${a}`);", "const a = 'a'; expect(() => { throw new Error('a'); }).toThrowError(`${a}`);", (0, _dedent.default)`
      test('Template literal', async () => {
        const a = 'a';
        const throwErrorAsync = async () => { throw new Error('a') };
        await expect(throwErrorAsync()).rejects.toThrow(\`\${a}\`);
        await expect(throwErrorAsync()).rejects.toThrowError(\`\${a}\`);
      })
    `,
  // Regex
  "expect(() => { throw new Error('a'); }).toThrow(/^a$/);", "expect(() => { throw new Error('a'); }).toThrowError(/^a$/);", (0, _dedent.default)`
      test('Regex', async () => {
        const throwErrorAsync = async () => { throw new Error('a') };
        await expect(throwErrorAsync()).rejects.toThrow(/^a$/);
        await expect(throwErrorAsync()).rejects.toThrowError(/^a$/);
      })
    `,
  // Function
  "expect(() => { throw new Error('a'); }).toThrow((() => { return 'a'; })());", "expect(() => { throw new Error('a'); }).toThrowError((() => { return 'a'; })());", (0, _dedent.default)`
      test('Function', async () => {
        const throwErrorAsync = async () => { throw new Error('a') };
        const fn = () => { return 'a'; };
        await expect(throwErrorAsync()).rejects.toThrow(fn());
        await expect(throwErrorAsync()).rejects.toThrowError(fn());
      })
    `,
  // Allow no message for `not`.
  "expect(() => { throw new Error('a'); }).not.toThrow();", "expect(() => { throw new Error('a'); }).not.toThrowError();", (0, _dedent.default)`
      test('Allow no message for "not"', async () => {
        const throwErrorAsync = async () => { throw new Error('a') };
        await expect(throwErrorAsync()).resolves.not.toThrow();
        await expect(throwErrorAsync()).resolves.not.toThrowError();
      })
    `, 'expect(a);'],
  invalid: [
  // Empty toThrow
  {
    code: "expect(() => { throw new Error('a'); }).toThrow();",
    errors: [{
      messageId: 'addErrorMessage',
      data: {
        matcherName: 'toThrow'
      },
      column: 41,
      line: 1
    }]
  },
  // Empty toThrowError
  {
    code: "expect(() => { throw new Error('a'); }).toThrowError();",
    errors: [{
      messageId: 'addErrorMessage',
      data: {
        matcherName: 'toThrowError'
      },
      column: 41,
      line: 1
    }]
  },
  // Empty rejects.toThrow / rejects.toThrowError
  {
    code: (0, _dedent.default)`
        test('empty rejects.toThrow', async () => {
          const throwErrorAsync = async () => { throw new Error('a') };
          await expect(throwErrorAsync()).rejects.toThrow();
          await expect(throwErrorAsync()).rejects.toThrowError();
        })
      `,
    errors: [{
      messageId: 'addErrorMessage',
      data: {
        matcherName: 'toThrow'
      },
      column: 43,
      line: 3
    }, {
      messageId: 'addErrorMessage',
      data: {
        matcherName: 'toThrowError'
      },
      column: 43,
      line: 4
    }]
  }]
});